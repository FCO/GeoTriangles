<html>
	<head>
		<style>
			body {
				margin: 0px;
				padding: 0px;
			}
		</style>
	</head>
	<body>
		<canvas id="myCanvas" width="1000" height="660"></canvas><BR>
		<input id="path"></input>
		<input id="pathDec"></input>
		<input id="pathInt"></input>
		<input id="pathHex"></input>
		<script>
			function Point2D(x, y) {
				this.x = x;
				this.y = y;
			}

			Point2D.prototype = {
				add:		function(point) {
					return new Point2D(this.x + point.x, this.y + point.y);
				},
				addX:		function(k) {
					return this.add(new Point2D(k, 0));
				},
				addY:		function(k) {
					return this.add(new Point2D(0, k));
				},
				subtract:	function(point) {
					return this.add(point.inverse());
				},
				subtractX:	function(k) {
					return this.addX(-k);
				},
				subtractY:	function(k) {
					return this.addY(-k);
				},
				inverse:	function() {
					return this.multiply(-1);
				},
				multiply:	function(k) {
					return new Point2D(this.x * k, this.y * k);
				},
				module:		function() {
					return Math.pow(Math.pow(this.x, 2) + Math.pow(this.y, 2), 1/2);
				}
			};

			function GeoTriangle(canvas, orig, orientationUp, sideSize, minSize, color, colorFill) {
				this.orig		= orig;
				this.orientationUp	= orientationUp;
				this.sideSize		= sideSize;
				this.minSize		= minSize;
				this.color		= color		|| GeoTriangle.defaultLineColor;
				this.defaultColor	= color		|| GeoTriangle.defaultLineColor;
				this.defaultColorFill	= colorFill	|| undefined;
				this.colorFill		= colorFill	|| undefined;
				this.canvas		= canvas;

				this.height = GeoTriangle.height(this.sideSize);

				this.A = this.orig;
				if(this.orientationUp) {
					this.B = this.orig.subtractX(this.sideSize/2).addY(this.height);
					this.C = this.orig.addX(this.sideSize/2).addY(this.height);
				} else {
					this.C = this.orig.subtractX(this.sideSize/2).subtractY(this.height);
					this.B = this.orig.addX(this.sideSize/2).subtractY(this.height);
				}

				if(this.sideSize / 2 > this.minSize) {
					this.hasChildren = true;
					this.createChildren();
				}
			}

			GeoTriangle.defaultLineColor = "#aaaaaa";

			GeoTriangle.height = function(sideSize) {
				return (sideSize/2) * Math.pow(3, 1/2);
			};

			GeoTriangle.sign = function(p1, p2, p3) {
				return (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y);
			}

			GeoTriangle.prototype = {
				getFromPath:	function(path) {
					if(path.length >= 2) {
						var subPath = path.substr(0, 2);
						path = path.substr(2);
						if(this.hasChildren && subPath in this.children) {
							if(path.length == 0)
								return this.children[subPath];
							else
								return this.children[subPath].getFromPath(path);
						}
					}
				},
				colorizePath:	function(path) {
					if(path.length >= 2) {
						var subPath = path.substr(0, 2);
						path = path.substr(2);
						if(this.hasChildren && subPath in this.children) {
							this.children[subPath].color		= "rgba(255, 0, 0, 0.5)";
							this.children[subPath].colorFill	= "rgba(255, 0, 0, 0.1)";
							this.children[subPath].draw(true);
							this.children[subPath].colorizePath(path);
						}
					}
				},
				createPath:	function(point) {
					var path = "";
					if(this.hasChildren) {
						Object.keys(this.children).forEach(function(key) {
							if(this.children[key].contains(point))
								path = key;
						}.bind(this));
						path += this.children[path].createPath(point);
					}
					return path;
				},
				contains:	function(point) {
					var b1 = GeoTriangle.sign(point, this.A, this.B) < 0;
					var b2 = GeoTriangle.sign(point, this.B, this.C) < 0;
					var b3 = GeoTriangle.sign(point, this.C, this.A) < 0;

					return ((b1 == b2) && (b2 == b3));
				},
				nearstVertice:	function(point) {
					var vertices = {}
					vertices[parseInt("" + point.subtract(this.A).module() * 100000)] = "A";
					vertices[parseInt("" + point.subtract(this.B).module() * 100000)] = "B";
					vertices[parseInt("" + point.subtract(this.C).module() * 100000)] = "C";

					var min = Math.min.apply(Math, Object.keys(vertices));
					return vertices[min];
				},
				resetColor:	function() {
					this.color = this.defaultColor;
					this.colorFill = this.defaultColorFill;
					if(this.hasChildren)
						Object.keys(this.children).forEach(function(key) {
							this.children[key].resetColor();
						}.bind(this));
				},
				clear:		function() {
					var context = this.canvas.getContext('2d');
					context.clearRect(0, 0, canvas.width, canvas.height);
					this.resetColor();
				},
				draw:		function(notRecursive) {
					var context = this.canvas.getContext('2d');
					context.beginPath();
					context.moveTo(this.A.x, this.A.y);
					context.lineTo(this.B.x, this.B.y);
					context.lineTo(this.C.x, this.C.y);
					context.lineTo(this.A.x, this.A.y);
					context.strokeStyle = this.color;
					context.closePath();
					if(this.colorFill) {
						context.fillStyle = this.colorFill;
						context.fill();
					}
					context.stroke();
					if(!notRecursive && this.hasChildren) {
						Object.keys(this.children).forEach(function(key) {
							this.children[key].draw();
						}.bind(this));
					}
				},
				createChildren:	function() {
					this.children = {
						"00": new GeoTriangle(
							this.canvas,
							this.orig.addY(this.height * (this.orientationUp ? 1 : -1)),
							!this.orientationUp,
							this.sideSize / 2,
							this.minSize
						),
						"01": new GeoTriangle(
							this.canvas,
							this.orig,
							this.orientationUp,
							this.sideSize / 2,
							this.minSize/*,
							"#ff0000"*/
						),
						"10": new GeoTriangle(
							this.canvas,
							this.orig.addX((this.orientationUp ? -1 : 1) * this.sideSize/4).addY((this.orientationUp ? 1 : -1) * this.height/2),
							this.orientationUp,
							this.sideSize / 2,
							this.minSize/*,
							"#00ff00"*/
						),
						"11": new GeoTriangle(
							this.canvas,
							this.orig.addX((this.orientationUp ? 1 : -1) * this.sideSize/4).addY((this.orientationUp ? 1 : -1) * this.height/2),
							this.orientationUp,
							this.sideSize / 2,
							this.minSize/*,
							"#0000ff"*/
						),
					};
				}
			};
			var canvas = document.querySelector("#myCanvas");

			function getMousePos(canvas, evt) {
				var rect = canvas.getBoundingClientRect();
				return new Point2D(evt.clientX - rect.left, evt.clientY - rect.top);
			}

			function toDec(path) {
				return path.replace(/\d{2}/g, function(match){
					return parseInt(match, 2);
				});
			}

			var t = new GeoTriangle(canvas, new Point2D(500, 0), true, 750, 25);
			//var t = new GeoTriangle(canvas, new Point2D(500, 700), false, 750, 10);
			t.draw();

			var reverse = {
				"0000": {
					"A":	function(path) {
						return path.replace(/0000$/, "0100");
					},
					"B":	function(path) {
						if(path.substr(-6, 2) == "00") {
							path = path.replace(/000000$/, "001000");
						} else {
							path = path.replace(/0000$/, "1000");
						}
						return path;
					},
					"C":	function(path) {
						if(path.substr(-6, 2) == "00") {
							path = path.replace(/000000$/, "001100");
						} else {
							path = path.replace(/0000$/, "1100");
						}
						return path;
					}
				},
				"0100": {
					"A":	function(path) {
						return path.replace(/0100$/, "0000");
					},
					"B":	function(path) {
						if(path.substr(-6, 2) == "00") {
							path = path.replace(/000100$/, "101100");
						} else if(path.substr(-6, 2) == "11") {
							path = path.replace(/110100$/, "001000");
						} else {
							path = path.replace(/0100$/, "1100");
						}
						return path;
					},
					"C":	function(path) {
						if(path.substr(-6, 2) == "00") {
							path = path.replace(/000100$/, "111000");
						} else if(path.substr(-6, 2) == "11") {
							path = path.replace(/110100$/, "001000");
						} else {
							path = path.replace(/0100$/, "1100");
						}
						return path;
					}
				},
			};

			canvas.addEventListener('mousemove', function(evt) {
				var mousePos = getMousePos(canvas, evt);
				if(t.contains(mousePos)) {
					var path = t.createPath(mousePos);
					document.querySelector("#path").value = path;
					document.querySelector("#pathDec").value = toDec(path);
					document.querySelector("#pathInt").value = parseInt(path, 2);
					document.querySelector("#pathHex").value = parseInt(path, 2).toString(16);
					t.clear();
					t.draw();
					t.colorizePath(path);

					var min = t.getFromPath(path);
					min.color = "green";
					min.colorFill = "rgba(0, 255, 0, 0.5)";
					min.draw(true);

					if(path.substr(-4) in reverse && min.nearstVertice(mousePos) in reverse[path.substr(-4)]) {
						var opositePath = reverse[path.substr(-4)][min.nearstVertice(mousePos)](path);
						var oposite = t.getFromPath(opositePath);
						oposite.color = "green";
						oposite.colorFill = "rgba(0, 255, 0, 0.5)";
						oposite.draw(true);
					}

					var center = min[min.nearstVertice(mousePos)];

					var context = canvas.getContext('2d');
					context.beginPath();
					context.arc(center.x, center.y, min.sideSize/10, 0, 2 * Math.PI, false);
					context.fillStyle = "rgba(0, 255, 0, 0.5)";
					context.fill();
					context.strokeStyle = 'green';
					context.stroke();
				}
			}, false);
		</script>
	</body>
</html> 
